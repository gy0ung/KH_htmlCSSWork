<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>배열</title>
    <style>
        .area {
            border : 1px solid;
            padding: 5px;
        }
    </style>
</head>
<body>
    <h1>배열</h1>
    <p>
        - 변수 선언시 별도의 자료형 지정하지 않은<br>
        - 어떤 자료형의 값들이든 모두 하나의 배열 공간에 담을 수 있음<br>
        - 크기에도 제약이 없다(자바의 컬렉션과 유사)<br>
        - 존재하지 않는 인덱스를 참조해도 오류나지 않음. undefined리턴
    </p>

    <div id="area1" class="area"></div>
    <button onclick="arrayTest();">확인하기</button>

    <script>
        function arrayTest() {
            const arr = ["홍길동", '서울', 20, true, [1,2,3]];   // 배열객체(type==object)

            console.log(arr);
            console.log(arr[2]);
            console.log(arr[4]);
            console.log(arr[4][2]);
            console.log(arr[8]);

            const area1 = document.getElementById("area1");
            // for(let i=0; i<arr.length; i++) {
            //     area1.innerHTML += `${arr[i]}<br>`;
            // }

            // for in문 활용
            // for(let 변수 in 배열) { }
            for(let index in arr) {
                area1.innerHTML += `${arr[index]}<br>`;
            }
        }
    </script>

    <h3>* 배열의 선언</h3>
    <button onclick="arrayTest2();">확인하기</button>

    <script>
        function arrayTest2() {
            const arr1 = new Array();
            const arr2 = new Array(3);
            const arr3 = [];

            console.log(arr1);
            console.log(arr2);
            console.log(arr3);

            // 배열에 값 대입
            arr1[0] = "바나나";
            arr1[1] = "딸기";
            arr1[9] = "키위";

            console.log(arr1);

            arr2[0] = "SM7";
            arr2[1] = "제네시스";
            arr2[2] = "캐딜락";
            arr2[3] = "K9";

            console.log(arr2);

            // 배열 선언과 동시에 초기화
            const arr4 = new Array("홍길동","임꺽정","신사임당");
            const arr5 = ["java","oracle","html5"];

            console.log(arr4);
            console.log(arr5);
        }
    </script>

    <hr>

    <h3>* 배열관련 메소드</h3>

    <h4>1) 배열.indexOf(찾고자하는요소) : 배열에서 해당 요소가 위치해있는 인덱스번호를 반환</h4>

    <div id="area2" class="area"></div>
    <button onclick="indexOfTest();">확인하기</button>

    <script>
        function indexOfTest() {
            const area2 = document.getElementById("area2");

            const arr = ["랍스타", "회덮밥", "부대찌개", "김치찌개", "김밥"];
            const menu = prompt("찾고자하는 점심메뉴 입력");

            const index = arr.indexOf(menu);

            // console.log(index);

            // 당신이 선택한 점심메뉴 ???은 판매하지 않습니다.
            // 당신이 선택한 점심메뉴 ???은 ?번째(index)에 있습니다.

            area2.innerHTML = `당신이 선택한 점심메뉴 ${menu}은 `;
            if(index == -1) {
                area2.innerHTML += "판매하지 않습니다.";
            } else {
                area2.innerHTML += `${index+1}번째에 있습니다.`;
            }

            // 자바스크립트에서 두 값이 동일한지 비교하는 연산자
            console.log(1 == 1)     // true 
            console.log("1" == 1)   // true : 동등연산자(자료형은 무관하게 실제값만 일치하는지 비교)
            console.log("1" === 1)  // false : 엄격동등연산자(값,자료형이 모두 일치하는지 비교)

            console.log("1" !== 1)  // true
        }
    </script>

    <br>

    <h4>2) 배열.concat(배열, 배열, ...) : 배열에 여러개의 배열을 결합하고자 할 때 사용</h4>

    <div id="area3" class="area"></div>
    <button onclick="concatTest();">확인하기</button>

    <script>
        function concatTest() {
            const area3 = document.getElementById("area3");

            const arr1 = ["사과","바나나"];
            const arr2 = ["딸기","파인애플","포도"];

            area3.innerHTML = `arr1 기준으로 배열 합침 : ${arr1.concat(arr2)}<br>`;
            area3.innerHTML += `원본 arr1 : ${arr1}<br>`;
            // 원본배열에 영향을 끼치지 않는다

            area3.innerHTML += `arr2 기준으로 배열 합침 : ${arr2.concat(arr1)}<br>`;
            area3.innerHTML += `원본 arr2 : ${arr2}<br>`;
        }
    </script>

    <br>

    <h4>3) 배열.reverse() : 배열에 담긴 값들을 역순으로 바꿔주는 메소드</h4>

    <div id="area4" class="area"></div>
    <button onclick="reverseTest();">확인하기</button>

    <script>
        function reverseTest() {
            const area4 = document.getElementById("area4");

            const arr = [1, 2, 3, 4, 5];

            area4.innerHTML = `arr : ${arr}<br>`;
            area4.innerHTML += `reverse 결과 : ${arr.reverse()}<br>`;
            // 원본배열에 영향을 끼치는 메소드
            area4.innerHTML += `arr : ${arr}<br>`;

        }
    </script>

    <br>

    <h4>4) 배열.sort() : 배열에 담긴 값들을 오름차순 정렬시켜주는 메소드</h4>

    <div id="area5" class="area"></div>
    <button onclick="sortTest();">확인하기</button>

    <script>
        function sortTest() {
            const area5 = document.getElementById("area5");

            const arr = ["김길동", "황길동", "이길동", "박길동", "강길동"];

            area5.innerHTML = `arr : ${arr}<br>`;
            area5.innerHTML += `sort결과 : ${arr.sort()}<br>`;
            // 원본배열에 영향을 끼치는 메소드
            area5.innerHTML += `arr : ${arr}<br>`;

            // 정렬이 안되어 있을 때, 내림차순으로 정렬하려면
            area5.innerHTML += `내림차순 정렬 : ${arr.sort().reverse()}<br>`;
        }
    </script>

    <br>

    <h4>
        5_1) 배열.push(추가할요소) : 배열 맨 마지막에 요소 추가시키고 배열의 크기 반환<br>
        5_2) 배열.pop() : 배열의 맨 마지막 요소 삭제하고 삭제한요소를 반환
    </h4>

    <div id="area6" class="area"></div>
    <button onclick="pushPopTest();">확인하기</button>

    <script>
        function pushPopTest() {
            const area6 = document.getElementById("area6");

            const arr = ["당산동", "서초동", "방배동", "삼성동", "대치동"];
            area6.innerHTML = `arr : ${arr}<br>`;
            area6.innerHTML += `arr에 push후 : ${arr.push("대방동")}<br>`;
            area6.innerHTML += `삽입 후 arr의 값 : ${arr}<br>`;
            // 원본 배열에 영향을 끼치는 메소드

            area6.innerHTML += `arr에 pop후 : ${arr.pop()}<br>`;
            area6.innerHTML += `삭제 후 arr의 값 : ${arr}<br>`;
            arr.pop();
            arr.pop();
            arr.pop();
            area6.innerHTML += `최종 arr의 값 : ${arr}<br>`;

        }
    </script>

    <br>

    <h4>
        6_1) 배열.unshift(추가할요소) : 배열의 맨 앞에 요소 추가 후 배열의 크기 반환<br>
        6_2) 배열.shift() : 배열의 맨 앞의 요소를 제거하고 제거된 요소를 반환
    </h4>

    <div id="area7" class="area"></div>
    <button onclick="shiftUnshiftTest();">확인하기</button>

    <script>
        function shiftUnshiftTest() {
            const area7 = document.getElementById("area7");

            const arr = ["농구","축구","야구","테니스"];
            area7.innerHTML = `arr : ${arr}<br>`;

            area7.innerHTML += `arr에 unshift후 : ${arr.unshift("볼링")}<br>`;
            area7.innerHTML += `arr : ${arr}<br>`;

            arr.shift();
            arr.shift();
            area7.innerHTML += `arr에 shift후 배열값 : ${arr}<br>`;
        }
    </script>

    <br>

    <h4>
        7_1) 배열.slice(시작인덱스, 끝인덱스) : 배열의 시작인덱스부터 끝인덱스까지 추출하는 메소드<br>
        7_2) 배열.splice(시작인덱스, 제거수[, 추가할 값]) : 배열의 요소 추출하여 제거 및 추가
    </h4>

    <div id="area8" class="area"></div>
    <button onclick="sliceTest();">확인하기</button>

    <script>
        function sliceTest() {
            const area8 = document.getElementById("area8");

            const arr = ["Java", "JSP", "Oracle", "HTML", "CSS"];
            area8.innerHTML = `arr : ${arr}<br>`;

            // slice(시작,끝) : 원본배열에 영향을 끼치지 않는 메소드
            area8.innerHTML += `slice 결과 : ${arr.slice(2,4)}<br>`;
            area8.innerHTML += `arr : ${arr}<br>`;

            // splice(시작, 제거수, 추가할 값) : 원본배열에 영향을 끼치는 메소드
            area8.innerHTML += `splice 결과 : ${arr.splice(2,1,"Spring","JS","JQuery")}<br>`;
            arr.splice(2,2); // 삭제만
            area8.innerHTML += `arr : ${arr}<br>`;
        }
    </script>

    <br>

    <h4>8) 배열.toString() / 배열.join([구분자]) : 배열에 각 인덱스에 담긴 값들을 하나의 "문자열"로 합쳐서 반환</h4>

    <div id="area9" class="area"></div>
    <button onclick="toStringTest();">확인하기</button>

    <script>
        function toStringTest() {
            const area9 = document.getElementById("area9");

            const arr = ["Java", "JSP", "Oracle", "HTML", "CSS"];
            area9.innerHTML = `arr : ${arr}<br>`;
            // 객체를 출력하면 내부적으로 객체.toString() 호출한 결과 출력
            area9.innerHTML += `toString : ${arr.toString()}<br>`;

            area9.innerHTML += `join : ${arr.join()}<br>`;
            area9.innerHTML += `구분자를 넣어 join : ${arr.join(" ")}<br>`;
            area9.innerHTML += `구분자를 넣어 join : ${arr.join(" / ")}<br>`;
            area9.innerHTML += `구분자를 넣어 join : ${arr.join("")}<br>`;
        }
    </script>

    <br>

    <h4>9)반복처리(for문, for..in문, for..of문, forEach)</h4>

    <div id="area10" class="area"></div>
    <button onclick="forTest();">확인하기</button>

    <script>
        function forTest() {
            const area10 = document.getElementById("area10");

            const arr = ["가", "나", "다"];

            area10.innerHTML = "for : ";
            for(let i=0; i<arr.length; i++) {
                area10.innerHTML += `${arr[i]}, `;
            }

            // 배열에 인덱스를 이용하여 값 가져오기
            area10.innerHTML += "<br>for..in : ";
            for(let i in arr) {
                area10.innerHTML += `${i} : ${arr[i]}, `;
            }

            // 배열의 요소값 가져오기
            area10.innerHTML += "<br>for..of : ";
            for(let ch of arr) {
                area10.innerHTML += `${ch}, `;
            }

            // 각 요소별로 전달할 함수(콜백함수)를 실행
            area10.innerHTML += "<br>forEach : <br>";
            arr.forEach(function(elem, index, arr) {
                area10.innerHTML += `인덱스번호 : ${index}, 값 : ${elem}<br>`;
            });
        }
    </script>

    <br>

    <h4>
        10_1) map : 배열의 각 요소별 작업 후 새 요소를 담은 배열 반환<br>
        10_2) filter : 각 요소별 콜백함수를 실행하여 true인 요소만 새 배열에 담아 반환<br>
        10_3) reduce : 모든 요소를 대상으로 특정작업 후 하나의 값(객체)로 반환<br>
                       - 최대/최소값, 누적합 등의 작업에 적합<br>
                       - reduce(콜백함수, 초기값) : 초기값 생략시 배열의 첫번째 요소가 초기값이 됨
    </h4>

    <div id="area11" class="area">  
        <ul></ul>
    </div>
    <button onclick="mapTest();">map</button>
    <button onclick="filterTest();">filter</button>
    <button onclick="reduceTest();">reduce</button>

    <script>
        const garea11 = document.getElementById("area11");
        function mapTest() {
            const arr = [1,2,3,4];  // [1,4,9,16]
            const arr2 = arr.map(function(elem) {
                console.log(elem);
                return elem*elem;
            });
            console.log(arr);
            console.log(arr2);

            
            const names = ["신사임당","세종대왕","이순신"];
            const nameList = names.map(function(name, i, arr) {
                return `<li>${name}</li>`;
            });

            const area11 = document.querySelector("#area11>ul");
            // for(let i=0; i<nameList.length; i++) {
            //     area11.innerHTML += nameList[i];
            // }

            // for in (index번호)
            // for(let x in nameList) {
            //     area11.innerHTML += nameList[x];
            // }

            // for of(요소값)  y = <li>신사임당</li>
            // for(let y of nameList) {
            //     area11.innerHTML += y;
            // }

            nameList.forEach(function(li) {
                area11.innerHTML += li;
            });

        }

        function filterTest() {
            const nums = [1,2,3,4,5,6,7,8,9,10];
            const even = nums.filter(function(elem) {
                return elem % 2 == 0;
            });
            garea11.innerHTML = `1~10까지 짝수 : ${even}<br>`;

            // 배열을 만들어서 1~100까지 값 넣기
            const arr = [];
            for(let i=0; i<100; i++) {
                arr.push(i+1);
            }
            
            // arr배열에서 31이하이면서 3의 배수만 배열에 넣어서 출력
            const arr3 = arr.filter(function(n) {
                return n < 31 && n % 3 == 0;
            });
            garea11.innerHTML += `31이하값중 3의 배수 : ${arr3}`;
        }

        function reduceTest() {
            const nums = [1,2,3,4,5,6,7,8,9,10];
                                        // pv 초기값 / elem 변수값
            const sum = nums.reduce(function(pv, elem, index, arr) {
                return pv + elem;
            },0);
            //console.log(sum);
            garea11.innerHTML = `1~10까지 합 : ${sum}`;
        }
    </script>
</body>
</html>